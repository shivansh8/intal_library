PES1201801966

Shivansh  Kohli

Intal is a library that deals with large positive integers of arbitrary lenghts. since these large integers cannot be represented by any of the predefined integer data types(int, long int, long long int, long long long int and its unsigned counterparts),  they are represented as strings.they always end with the null termination character and do not contain any leading zeroes. the maximum number that can be represented is 10^1000 and the minimum is 0. 
many operations on these intals can be performed, including basic arithmetic operations like addition, subtraction, multiplication anf modulus(remainder). some other functions like fibonacci and factorial are also included. we can search and sort an array of intals. 
applications of intal includes fields where mathematical calculation with very large numbers are done, for example, in astronomy.cryrptography also has applications with very large integers.
implementation: 
intal_add: i check the length of both inputs and decide which has greater length. then i run a loop of the size of smaller length and add the corresponding digits of both intals, taking the carry as we go along. once out of this loop, i check for the last carry again and add it to the next digit of the intal of greater length, if the carry is  present. then i copy the rest of the greater length of the intal to the answer and add the null termination at the end. then i return it.
intal_compare: i check for the length of both inputs. if length are not same, i return the corresponding value for the intal whose length is greater(1 for intal 1 and -1 for intal2). if both length are same, i individually check for each digit in both numbers and decide which is greater, in a loop. if the loop exits normally, then they are the same number and i return 0.
intal_diff: i check fort the greater number using intal_compare and copy the greater number in intal 1 and the smaller in intal 2. if both are same i return 0. i also add null termination while copying if not already present in the input. then i subtract the lesser intal from the greater, keeping in mind of the borrow. i subtract 1 from the next msb (the digit to the left of the current digit) . after subtraction, if the next msb is -1, this means the digit was 0. so i check and keep going left until i find the next non 0 digit, subtract 1 from it, and make all digits to hte right of it as 9 till i reach the current digit. this takes care of cases like 10000-1. next i copy this to another char pointer and while doing so, i check to avoid any leading zeroes to be copied. i null terminate this pointer and return it.
intal_multiply: the implementation is of how we multiply numbers on paper. i find the number of lesser length and make it the outer loop. the number of greater length is in the ineer loop.there is a pointer for each multiplication of a digit of the lesser length number with the greater length number. this is added to the result using intal_add. while multiplying the carry is taken care of. there is an inner loop to decide the number of zeroes to suffix for each pointer. example, for 102*25, when 5 is multiplied with 102, no 0 is suffixed. when 2 is multiplied, 1 0 is suffixed. the result is transferred to another null termnated char pointer and the result is returned.
intal_mod: if intal 1 is lesser than intal2, it is returned. else intal2 is made to come as close to intal 1 as possible, by suffixing zeroes and making the length of intal equal to ar 1 lesser than that of intal1 ,and repeated subtraction takes place.this process continues with the subtracted number. for example, 809 mod 6,6 is made as 600 and subtracted from 809, which becomes 209. now since 209<600, 1 zero is dropped . this decision is made by compairing the 1st few digits of both numbers until it is found which has a digit of greater magnitude. this is done by another static function.now, 60 is subtracted from 209 3 times to get 39. since 60> 39, another 0 is removed from suffix. now 6 is subtracted 6 times to get 3, which is lesser than 6, the intal2. thus, this process stops when the number becomes lesser than equal to the intal2. this result is null terminated and returned.
intal_gcd: using euclids algorithm, gcd is found. gcd(m,n)=gcd(n,m mod n), until the 2nd argument is 0. then the 1st argument is the answer, which is null terminated and returned.
intal_power: using the algorithm taught in class, i implement power using another static function, which recursively finds the factorial. i recursively call the function , sending n/2 as the integer argument until n equals 0 . then i return "1", and in multiply the returned value with the intal. if n is odd in that stack frame , then i again multiply the value with the intal . i use a static function for this .in the end i null terminate it and return it. 
intal_fibonacci: i make an array of pointers, define the 1st 2 integers of the fibonacci series and in a loop find the fibonacci number by adding the latest 2 numbers of the pointer array. i null terminate the last pointer in the array and return it.
intal_factorial: i find the factorial in the traditional way in a loop, and null terminate it and return it. i start with a pointer with value 1, and multiply with the number. then keep decreasing the number by 1 and multiplying with the previous value obtained. then i return the value once the loop is completed.
intal_max: i find the maximum using the intal_compare, compairing the intal at max index and each index from 1 to n-1, initially assuming 0 index intal as max. if any intal is greater than max intal, max is offset of that intal. return max;
intal_min:i find the minimum using the intal_compare, compairing the intal at min index and each index from 1 to n-1, initially assuming 0 index intal as min. if any intal is lesser than min intal, min is offset of that intal.return min;
intal_search: search for the key using intal_compare, in a linear search fashion. if found, return offset, else return -1;
intal_sort: used merge sort to sort the given array of intals. merge sort breaks down the array elements to their individual values and then while merging, sorts them.
intal_binsearch: used normal binary search to search the key .along with that, when key is found, i check if its the 1st key or not, by compairing its value with the previous element in the sorted aray. if found, return off set, else  return-1;
intal_bincoefficient: i use dynamic programming and an array of size k+1 of type intal, to store values while calculating nCk.the base value is 1 for 1C1. there are 2 loops, the outer goes from 1 to n and the inner ,the maximum of k and outer loop index, to 1. this represents the inner loop going from iCi to iC1, where i is the outer loop index. value of an index in the array is calculated by adding the preexisting value to the value to the left index in the array of the current index. the value of kth index is returned after null termination.
coin_row_problem: 
executed the coin row algorithm as was taught in the class. (except used 3 pointers instead of the dp table). 
the value at ith index is found by  the maximum of array[i-1]+pointer to the max value of the i-2th iteration and pointer to the maximum value of the i-1th iteration; 
thus as the loop progresses, we keep changing the pointers to point from 1 to another depending on the maximum value obtained.
 i uset pointer t to point to the i-2th value and t1 to point to the i-1th value.
 pointer r1  takes the addition value of t and i-1th value from array.if maximum is  r1,free t, t=t1, t1=r1 and r1, which is a static pointer is set to null. else t=t1 and r1= null; in the end, t1 holds the value to be returned. this value is copied to another array, is null terminated and returned.the other pointers and checked (if they point to same location or not, so that i dont free pointers pointing to same location twice) and freed.

future work: 
division was a basic arithmetic operation which was missing. this can be implemented (though its implementation would bevery similar to mod). permutations can also be found.
with no restrictions, i would implement it in python, sice it is easier to work with strings in python. also python can hold integers whose value is much greater than the maximum value that an c integer can hold.